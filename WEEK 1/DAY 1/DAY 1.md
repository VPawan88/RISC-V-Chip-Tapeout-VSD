# Week 1 - Day 1

The first day of the India **RISC-V SoC Tapeout Program** focused on understanding the basics of Verilog design and open-source digital design tools. The sessions introduced key concepts and provided hands-on practice with open-source EDA tools for RTL design and synthesis.

### Topics Covered

1. **Introduction to Verilog RTL Design and Synthesis**

   * Overview of Register Transfer Level (RTL) design principles.
   * Basics of writing synthesizable Verilog code.

2. **Introduction to Open-Source Simulator Icarus Verilog (iverilog)**

   * Understanding the simulation flow.
   * Compiling and running Verilog testbenches using iverilog.

3. **Labs using Icarus Verilog and GTKWave**

ğŸ–¥ï¸Running the MUX Simulation

RTL Code â†’ Simulation â†’ Synthesis Script + Library â†’ Yosys â†’ Gate-Level Netlist

1ï¸âƒ£ **Write RTL Code**  
2ï¸âƒ£ **Prepare a Synthesis Script**  
3ï¸âƒ£ **Choose a Target Library**  
4ï¸âƒ£ **Run Synthesis**

---

### ğŸ”€ What is a Multiplexer (MUX)?
A Multiplexer (MUX) is a combinational circuit that selects one of several inputs and forwards it to a single output lineâ€”like a digital switch.

**Why MUX is Important**
- Used in CPUs to select data paths  
- Helps decision-making circuits  
- Reduces hardware by sharing one output channel

---

### ğŸ’» RTL Code: `good_mux.v`
```verilog
module good_mux (
    input i0,
    input i1,
    input sel,
    output reg y
);
always @(*) begin
    if (sel)
        y <= i1;
    else
        y <= i0;
end
endmodule
```

### ğŸ’» Testbench Code: `tb_good_mux.v`
```
`timescale 1ns / 1ps
module tb_good_mux;
	// Inputs
	reg i0,i1,sel;
	// Outputs
	wire y;

        // Instantiate the Unit Under Test (UUT)
	good_mux uut (
		.sel(sel),
		.i0(i0),
		.i1(i1),
		.y(y)
	);

	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end

always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
ğŸ“œ Commands Used
Compile the mux with testbench
  ```
iverilog good_mux.v tb_good_mux.v
```
Run the simulation
  ```
./a.out
```
Open the waveform in GTKWave
  ```
gtkwave tb_good_mux.vcd
```
<img width="1619" height="768" alt="Screenshot 2025-09-24 045224" src="https://github.com/user-attachments/assets/3aa61f39-ddd2-430a-a805-f6c6118f56c6" />


âœ… Result
```
When sel = 0 â†’ y = i0

When sel = 1 â†’ y = i1
```

4. **Synthesis using Yosys**
ğŸ› ï¸ What is Synthesis?

Synthesis is the process of converting your high-level Verilog code (RTL) into a gate-level netlist, which is a structural description of your circuit using basic logic gates. The output of this process is a new Verilog file that represents the synthesized circuit.

ğŸ“œ Commands Used

Read the Verilog design file
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog good_mux.v
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
Perform generic synthesis steps
```
synth -top good_mux
```
Write the synthesized netlist to a new file
```
write_verilog good_mux_netlist.v
```
Generated by Yosys 0.9
```
module good_mux(i0, i1, sel, y);
  wire 0;
  wire 1;
  wire 2;
  wire 3;
  input i0;
  input i1;
  input sel;
  output y;
  sky130_fd_sc_hd_mux2_1 _4 (
    .A0(0),
    .A1(1),
    .S(2),
    .X(3)
  );
  assign 0 = i0;
  assign 1 = i1;
  assign 2 = sel;
  assign y = 3;
endmodule
```
Run 
```
show
```
<img width="1075" height="647" alt="Screenshot 2025-09-24 051736" src="https://github.com/user-attachments/assets/97c10862-8ff2-4222-9b3e-3baf0cf0426e" />

4. **sky130_fd_sc_hd__tt_025C_1v80.lib**

ğŸŒ Sky130 Library File: sky130_fd_sc_hd__tt_025C_1v80.lib

This is a Liberty (.lib) timing and power model used during synthesis.
It provides:

Standard-cell definitions: NAND, NOR, MUX, DFF, etc.

Timing characteristics: propagation delays, setup/hold times

Power data: dynamic and leakage power for each cell

Operating conditions:

tt â€“ typicalâ€“typical process corner

25 Â°C â€“ temperature

1.8 V â€“ supply voltage

During synthesis, Yosys reads this .lib to map RTL logic into actual gate-level cells with accurate timing and power estimates.


This concludes **Day 1** with a strong foundation in Verilog RTL design and essential open-source EDA tools.

